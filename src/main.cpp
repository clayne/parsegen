#include "lalrbld.h"

#include <fstream>

template<typename Iter>
void outputData(std::ostream& ofile, Iter from, Iter to, size_t ntab = 0) {
    auto convert_to_string = [](const auto& v) {
        if constexpr (std::is_constructible<std::string, decltype(v)>::value) {
            return '\"' + v + '\"';
        } else {
            return std::to_string(v);
        }
    };

    if (from == to) { return; }
    const unsigned length_limit = 120;
    std::string tab(ntab, ' '), line = tab + convert_to_string(*from);
    while (++from != to) {
        auto sval = convert_to_string(*from);
        if (line.length() + sval.length() + 3 > length_limit) {
            ofile << line << "," << std::endl;
            line = tab + sval;
        } else {
            line += ", " + sval;
        }
    }
    ofile << line << std::endl;
}

template<typename Iter>
void outputArray(std::ostream& ofile, std::string_view array_name, Iter from, Iter to) {
    if (from == to) { return; }
    if constexpr (std::is_constructible<std::string_view, decltype(*from)>::value) {
        ofile << std::endl << "static const char* ";
    } else {
        ofile << std::endl << "static int ";
    }
    ofile << array_name << "[" << std::distance(from, to) << "] = {" << std::endl;
    outputData(ofile, from, to, 4);
    ofile << "};" << std::endl;
}

//---------------------------------------------------------------------------------------

int main(int argc, char** argv) {
    try {
        std::string input_file_name;
        std::string analyzer_file_name("par_analyzer.inl");
        std::string defs_file_name("par_defs.h");
        std::string report_file_name;
        for (int i = 1; i < argc; ++i) {
            std::string_view arg(argv[i]);
            if (arg == "-o") {
                if (++i < argc) { analyzer_file_name = argv[i]; }
            } else if (arg == "-h") {
                if (++i < argc) { defs_file_name = argv[i]; }
            } else if (arg == "--report") {
                if (++i < argc) { report_file_name = argv[i]; }
            } else if (arg == "--help") {
                // clang-format off
                static const char* text[] = {
                    "Usage: parsegen [options] file",
                    "Options:",
                    "    -o <file>           Place the output analyzer into <file>.",
                    "    -h <file>           Place the output definitions into <file>.",
                    "    --report <file>     Place analyzer build report into <file>.",
                    "    --help              Display this information.",
                };
                // clang-format on
                for (const char* l : text) { std::cout << l << std::endl; }
                return 0;
            } else if (arg[0] != '-') {
                input_file_name = argv[i];
            } else {
                std::cerr << "parsegen: unknown flag `" << arg << "`." << std::endl;
                return -1;
            }
        }

        if (input_file_name.empty()) {
            std::cerr << "parsegen: no input file specified." << std::endl;
            return -1;
        }

        std::ifstream ifile(input_file_name);
        if (!ifile) {
            std::cerr << "parsegen: cannot open input file `" << input_file_name << "`." << std::endl;
            return -1;
        }

        LRBuilder lr_builder;
        int res = lr_builder.loadGrammar(ifile);
        if (res != 0) {
            std::cerr << std::endl << lr_builder.getErrorString() << std::endl;
            return res;
        }
        lr_builder.buildAnalizer();

        if (std::ofstream ofile(defs_file_name); ofile) {
            ofile << "// Parsegen autogenerated definition file - do not edit!" << std::endl;
            if (const auto& token_list = lr_builder.getUsedTokenList(); !token_list.empty()) {
                ofile << std::endl << "enum {" << std::endl;
                int last_id = 0;
                for (const auto& [name, id] : lr_builder.getUsedTokenList()) {
                    ofile << "    tt_" << name;
                    if (id > last_id + 1) { ofile << " = " << id; }
                    ofile << "," << std::endl;
                    last_id = id;
                }
                ofile << "};" << std::endl;
            }

            if (const auto& action_list = lr_builder.getActionList(); !action_list.empty()) {
                ofile << std::endl << "enum {" << std::endl;
                ofile << "    act_" << action_list[0] << " = " << 0 << "," << std::endl;
                for (size_t i = 1; i < action_list.size(); ++i) {
                    ofile << "    act_" << action_list[i] << "," << std::endl;
                }
                ofile << "};" << std::endl;
            }
        } else {
            std::cerr << "parsegen: cannot open output file `" << defs_file_name << "`." << std::endl;
        }

        std::vector<int> action_idx, action_list, goto_idx, goto_list;
        lr_builder.compressTables(action_idx, action_list, goto_idx, goto_list);

        if (std::ofstream ofile(analyzer_file_name); ofile) {
            ofile << "// Parsegen autogenerated analyzer file - do not edit!" << std::endl;
            const auto& prod_info = lr_builder.getProdInfo();
            const auto& token_text = lr_builder.getTokenText();
            outputArray(ofile, "prod_info", prod_info.begin(), prod_info.end());
            outputArray(ofile, "action_idx", action_idx.begin(), action_idx.end());
            outputArray(ofile, "action_list", action_list.begin(), action_list.end());
            outputArray(ofile, "goto_idx", goto_idx.begin(), goto_idx.end());
            outputArray(ofile, "goto_list", goto_list.begin(), goto_list.end());
            outputArray(ofile, "token_text", token_text.begin(), token_text.end());
        } else {
            std::cerr << "parsegen: cannot open output file `" << analyzer_file_name << "`." << std::endl;
        }

        if (!report_file_name.empty()) {
            if (std::ofstream ofile(report_file_name); ofile) {
                lr_builder.printTokens(ofile);
                lr_builder.printNonterms(ofile);
                lr_builder.printActions(ofile);
                lr_builder.printGrammar(ofile);
                lr_builder.printFirstTbl(ofile);
                lr_builder.printAetaTbl(ofile);
                lr_builder.printStates(ofile, action_idx, action_list, goto_idx, goto_list);
            } else {
                std::cerr << "parsegen: cannot open output file `" << report_file_name << "`." << std::endl;
            }
        }

        return 0;
    } catch (const std::exception& e) { std::cerr << "parsegen: exception catched: " << e.what() << "." << std::endl; }
    return -1;
}
